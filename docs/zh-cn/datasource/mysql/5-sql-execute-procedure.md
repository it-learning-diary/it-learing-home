

# 一、前言

- 大家好,我是小诚,《从0到1-全面深刻理解MySQL系列》已经来到第四章,这一章节的主要从一条SQL执行的开始,由浅入深的解析SQL语句由客户端到服务器的完整执行流程,最终达到 "**知其然、知其所以然**" 的目的。
<br>


# 二、孽缘,一条SQL是如何被执行
<br>



&emsp;&emsp;前几天在网上进行了一个面试,关于数据库方面的面试题其实也没少背,但是这个面试官的问题多少让我有些触不及防,他没有询问比较常见的基础语法和优化的问题,**而是让我解释一条SQL从客户端到服务端的执行流程**,这让我十分尴尬,因为平时只顾应用层面的东西,没有真正去理解到更深层次的东西,所以遇到非常规问题,很容易蒙圈,**希望大家以我为鉴,学习一个知识要尽量达到"知其然、知其所以然",这样即使面试官变换问题的角度,我们也能更好的应对回答,叨唠完了,正片开始!**<br>

&emsp;&emsp;平常工作中,我们最常见的就是从客户端发送一条SQL到数据库服务端进行相应的数据表操作,其实抽象起来就是: **客户端(也就是我们的业务代码)发送了一段SQL文本，服务端接收到了一段SQL文本然后进行解析处理，最终返回一段文本(执行结果)。**
<br>

&emsp;&emsp;那实际上服务端是对客户端进行了哪些解析步骤的操作才最终返回执行结果的呢?这里我们首先通过一张图片形象的展示解析的流程,然后再对逐个流程进行具体的解析。

<br>
<center><img src="https://img-blog.csdnimg.cn/20210718123016855.png" /></center>

<br>

## 2.1、连接处理模块:<br>

&emsp;&emsp;**该模块主要是管理客户端的连接,客户端可以通过TCP/IP、命名管道、共享内存、套接字等方式与服务端进行连接,服务端接收到连接后,会专门生成一个线程去处理客户端的请求**,当完成客户端的请求后,该线程不会被销毁,而是放入线程池中,从而减少了频繁创建和删除线程的消耗,大大节省了系统资源和提高了效率。<br>

&emsp;&emsp;客户端每次发起连接请求时,都会携带用户名、密码等验证信息,如果服务器验证不通过,则会拒绝连接,同时,如果很多客户端同时请求连接,为了避免服务端程序崩溃和提高效率,可以限制最大的连接数量。
<br>

## 2.2、解析和优化模块
<br>

&emsp;&emsp;客户端和服务端建立完连接后,服务端会有专门的线程对客户端的请求做处理,此时服务端接收到的是客户端发送的一段文本信息,需要转换成自己可以识别的信息，具体步骤如下:
<br>

### 2.2.1、查询缓存
<br>

&emsp;&emsp;试想,周末晚上你用手机看电影学习经验,突然老板给来了个电话,让你去处理一个紧急事情,你不得不中断看电影去处理突发事件,处理完后你肯定是想从上一次播放的位置继续观看而不是从头观看,缓存的作用就体现在这里。
<br>

&emsp;&emsp;**为了提高响应效率,Mysql服务端程序会根据客户端请求的信息生成对应的缓存,如果请求的信息符合缓存中的,则直接返回,无需再去与底层进行更多的交互**。
<br>

&emsp;&emsp;但是、Mysql服务器程序并不能像人一样智能,如果两次的请求文本不一样如多了空格、大小写以及每次调用会返回不同的值的函数等情况时,都不会命中缓存,因为它无法判断多出来的这些东西是否会影响SQL最终执行的结果。
<br>

&emsp;&emsp;使用到了缓存,就涉及到对缓存维护,Mysql中的缓存检测程序会监测到缓存涉及的每一张表,如果表中的数据或者结构发生改变,如执行了insert、alter等命令时,那么它会将该表对应的缓存进行失效和删除。**因为维护缓存是需要很大的开销,特别是表很多的情况下,所以Mysql8.0时已经将查询缓存这个流程删除。**
<br>

### 2.2.2、语法解析
<br>

&emsp;&emsp;&emsp;&emsp;如果请求没有命中缓存,则进入到语法解析的步骤,因为服务端程序接收到的是客户端发送过来的文本信息,**Mysql服务端程序要从文本中将具体的请求含义解析出来,如查询什么字段,查询哪一些表等**<br>
### 2.2.3、查询优化
<br>

&emsp;&emsp;&emsp;&emsp;经过语法解析步骤后,服务端程序已经知道客户端请求的信息,如请求的表,数据等,但是,此时服务器程序还不会立马根据这些信息去执行.**它会解析出来的语句进行一些优化,如:子连接转为关联查询,内外连接查询等,以达到最大的优化效率,优化的结果就是生成一个执行计划**,就是平常我们使用Explain关键字看到的一个结果。
<br>

## 3、存储引擎模块

<br>

&emsp;&emsp;经过了连接处理和解析优化俩步骤后,实际上还是没有对实际的数据进行任何的处理,**Mysql中,将对数据存储和提取的操作抽取到了一个叫存储引擎的模块中**。
<br>

&emsp;&emsp;在逻辑上,我们看到的是表的数据是一行行的形式,**但实际物理层面上,表的数据如何存储、如何读取表的数据、这都是存储引擎需要负责的操作,Mysql中提供了不同的存储引擎,不同的存储引擎存储的数据结构可能不相同,采用的算法也可能不同**。
<br>

## 4、延伸
<br>

&emsp;&emsp;我们常在一些教学视频或者专业文章中看到MySQL Server层和存储引擎模块的概念,它们具体的含义如下:
<br>

&emsp;&emsp;**为了管理方便,将连接处理/管理、查询缓存、语法解析、查询优化等不涉及到真实数据存取的功能划分为Mysql Server层的功能。**
<br>

&emsp;&emsp;**把涉及到真实数据存取的功能划分为存储引擎模块的功能**,Mysql Server层通过各个存储引擎提供的API进行访问响应的存储引擎,Mysql通过查询优化生成了执行计划后,通过调用存储引擎提供的API获取到对应的数据返回给客户端即可。

<br>

# 三、MySQL流程常见面试题
<br>

### 3.1、数据库语句的执行顺序
 <br>

  &emsp;&emsp;**(一): 执行顺序** 
   <br>
  &emsp;&emsp;from -> on -> join -> where -> group by -> having -> count(聚合函数) -> select -> distinct -> order by -> limit
 <br>
  &emsp;&emsp;**(二): 执行步骤解释:**
 <br>
  &emsp;&emsp;(1)、from: 表示数据的来源
 <br>
  &emsp;&emsp;(2)、on: 表示数据的关联表,执行完后生成一个临时表t1,提供给下一步的操作使用
 <br>
  &emsp;&emsp;(3)、join: 将join表的数据补充到on执行完成的临时表t1中,如: left join则将坐标剩余的数据添加到临时表t1中,如果join超过3个,则重复on...join之间的步骤。
 <br>
  &emsp;&emsp;(4)、where: 根据携带的条件,从临时表中筛选出符合条件的数据,并生成临时表t2。
 <br>
  &emsp;&emsp;(5)、groub by: 根据携带的条件,将临时表t2进行相应的数据分组,并形成临时表t3,如果语句包含了group by则它后面的字段必须出现在select中或者出现在聚合函数中,否则会报SQL语法错误。
 <br>
  &emsp;&emsp;(6)、having: 筛选分组后临时表t3的数据,得到临时表t4。
 <br>
  &emsp;&emsp;(7)、count等聚合函数: 对临时表进行指定字段的聚合函数操作,形成临时表t5。
 <br>
  &emsp;&emsp;(8)、select: 从临时表筛选出需要返回的数据,形成临时表t6。
 <br>
  &emsp;&emsp;(9)、distinct: 对临时表t6进行指定的去重筛选,形成临时表t7。
 <br>
  &emsp;&emsp;(10)、order by: 对临时表t7排序,形成临时表t8。
 <br>
  &emsp;&emsp;(11)、limit: 筛选返回的数据条数
<br>

  &emsp;&emsp;想要了解更多的执行过程的问题,可以查看之前专门解析执行过程的文章:  [你真的懂使用Group by?](https://blog.csdn.net/qq_40891009/article/details/115429440?spm=1001.2014.3001.5501)

<br>




# 四、小结

<br>

&emsp;&emsp;从上文我们可以知道,MySQL服务端又划分为: MySQL Server层和存储引擎层。MySQL Server层主要负责进行客户端连接、语法解析、语法优化等操作,存储引擎层负责对实际数据的存取操作。
<br>

&emsp;&emsp;一条SQL语句完整的解析需要经历以下步骤: **客户端和服务端请求处理 -》查询缓存 -》语法解析 -》查询优化 -》存储引擎对数据存取 -》 返回处理结果**
<br>

&emsp;&emsp;  下次遇到面试官询问这种问题,直接甩这篇文章在他脸上。**最后、如果觉得文章对你有帮助,不要忘记一键三连哦,你的支持是我创作更加优质文章的动力,有任何问题可以私信我,看到会及时给你答复！**
<br>