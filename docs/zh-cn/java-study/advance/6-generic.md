
#### 一: 泛型知识点

![泛型知识点](https://img-blog.csdnimg.cn/20200830194120980.png)


#### 二: 泛型(generics)是什么

&emsp;&emsp;泛型是JDK1.5出现的一种新特性,它是一种语法糖,主要用来解决对象类型不确定的问题。<br></font>

&emsp;&emsp;延申知识:语法糖（Syntactic Sugar）,也称糖衣语法,指在计算机语言中添加的某种语法,这种语法对语言本身功能来说没有什么影响，只是为了方便程序员的开发,提高开发效率。说白了,语法糖就是对现有语法的一个封装。<br></font>

&emsp;常见的语法糖: 
 1. 泛型与类型擦除
 2. 自动装箱与拆箱，变长参数
 3. 增强for循环 
 4. 内部类与枚举类

&emsp;&emsp;泛型可以用在类、接口、方法中,分别称为泛型类、泛型接口、泛型方法。<br></font>

&emsp;&emsp;**一:泛型类(具有一个或者多个类型变量的类)**

```java
// K,V表示泛型,编译的时候不知道具体的类型,实例化的时候需要指定具体的类型
public genericClass<K,V> xxxx
```
&emsp;&emsp;**二:泛型接口(具有一个或者多个类型变量的接口)**

```java
// K,V表示泛型,编译的时候不知道具体的类型,实现接口的时候需要指定
public interface genericInterface<K> xxx
```

&emsp;&emsp;**三:泛型方法(具有一个或者多个类型变量的方法)**

```java
//  K,V表示泛型,编译的时候不知道具体的类型,调用方法的时候需要指定具体的类型
public <T> void genericMethod(T,V)
```
&emsp;&emsp;**四:泛型方法为什么需要在返回值类型前添加泛型类型,不然就报错?<br>**

&emsp;&emsp;答:这是java声明泛型方法的固定格式，在方法的返回值声明之前的位置，<T>定义该方法所拥有的泛型标识符，个数可以是多个。



#### 三: 使用泛型有什么好处
&emsp;&emsp;在JDK1.5以前,如果我们不知道对应的类型,可以先使用Object类型来占位,但是后面存在的问题: 需要强制转换,可能存在类型转换错误。<br></font>

&emsp;&emsp;1、**安全性**: 在编译期会进行类型检查,类型不对会报错,并且泛型的强制类型转换是自动和隐式的,避免了强制类型转换时可能出现的类型转换(ClassCastException)错误。<br>

&emsp;&emsp;2、**提高代码的重用性**: 泛型的强制转换都是自动和隐式的。<br>

&emsp;&emsp;3、**增强可读性**。




#### 四: 如何使用泛型
&emsp;&emsp;(一) 泛型的目的是为了解决当对象的类型不确定时,参数类型如何定义的问题,所以,当参数类型没有确定的时候,可以使用泛型的通配符进行占位。<br>

&emsp;&emsp;(二) 泛型中常见的通配符号: T、K、V、?等,他们并不是一定的,只是编码中的一个约定俗称的东西,我们可以使用A-Z随便的字母进行替换,但是,使用约定俗称的通配符号可以提高可读性,它们表达的具体含义如下:

 1. **"?" 通常表示不确定的Java类型**
 2. **"T" 表示某个具体的Java类型**
 3. **"K" 代表java键值中的Key**
 4. **"V" 代表java键值中的Value**
 5. **"E" 代表Element(某个元素)**

&emsp;&emsp;(三) 常见的通配符类型<br>

&emsp;&emsp;**1、无边界通配符:** <?> 表示没什么限制,无界通配符则表明在使用泛型，如果不指定,则不能添加任何值。<br>

&emsp;&emsp;**2、上边界限定通配符**,如 <?extendsE>; extends关键字表示这个泛型中的参数必须是 E 或者 E 的子类。<br>

&emsp;&emsp;**3、下边界通配符**，如 <? super E>; super关键字表示这个泛型中的参数必须是所指定的类型E，或者是此类型的父类型，直至 Object。



#### 五: 泛型的底层实现
&emsp;&emsp;**(一) 泛型是在编译期进行类型校验,如果类型校验不通过,则会编译报错,它底层是通过编译器进行实现的。**<br>

&emsp;&emsp;**(二) 类型擦除: 泛型校验只在编译阶段,在编译生成的字节码中都不包含泛型中的类型参数,这就是泛型擦除,例子如下**:

```java
List<Apple> list1 = new ArrayList<>();
List<Fruit> list2 = new ArrayList<>();
// 结果是true
System.out.println(list1.getClass() == list2.getClass());
```

#### 六: 泛型的局限

 1. 在指定泛型类型时,不能使用基本类型,只能指定它们的包装类型，如: Person"<"double">",因为泛型本质是obejct类型,是引用类型,而不是原始类型(原始类型也就是我们常说的八种基本类型,他们都是存储值在栈中,而引用类型存储的是对象的地址)。

 2. 不能够直接实例化类型变量,如:new T(...)，newT[...] 或 T.class。 


#### 七: 常见的泛型面试题
**(一) Java中的泛型是什么 ?**

&emsp;&emsp;答: 泛型是JDK1.5的新特性,它只是一个语法糖,用于解决类、接口、方法、属性对象类型不确定的问题。

**(二)使用泛型的好处是什么?**

&emsp;&emsp;1、在编译期间会进行类型检查,添加了安全性(安全性)

&emsp;&emsp;2、强制类型转换都是自动和隐式的,提高了代码的重用效率(简洁性)

&emsp;&emsp;3、增加了可读性

**(三)Java的泛型是如何工作的 ?**

&emsp;&emsp;答: 它是通过编译器实现的,在编译期间进行类型检查

**(四)什么是类型擦除 ?**

&emsp;&emsp;泛型只存在编译的时候,在运行时会转换成具体的原始类型,即在运行的时候会"擦除"类型的概念。

&emsp;&emsp;泛型只在编译阶段,在编译生成的字节码中都不包含泛型中的类型参数> 

**(五)什么是泛型中的限定通配符和非限定通配符 ?**

&emsp;&emsp;限定通配符对类型进行了限制;泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面表示了非限定通配符，因为可以用任意类型来替代。<br>

&emsp;&emsp;限定通配符: 又分为上边界通配符<? extends E>、下边界通配符<? super E>

 1. 上边界通配符<? extends E> 表示: 泛型参数必须是E类型或者E的子类

 2. 下边界通配符<? super E> 表示: 泛型参数必须是E或者E的父类,直至Object类型

&emsp;&emsp;非限定通配符: 类型为“<‘T’>”,可以用任意类型来替代,它表示没有任何的限制,泛型参数可以是任意符合条件的类型。

**(六)List<'T'>和List <?>之间有什么区别 ?**
&emsp;&emsp;泛型的使用场景有以下两种:

 1. 声明一个泛型类或者泛型方法

 2. 使用泛型类或者泛型方法

 &emsp;&emsp;<'T'> : 使用场景是第一种即: 声明泛型类、方法、接口,使用类型参数的目的是解决对象类型不确定的情况。如:


```java
public class ArrayList<T> extends AbstractList<T>{}
```

  &emsp;&emsp;<’?‘>: 主要是用于第二种: 使用泛型类或者泛型方法(不推荐使用,因为这样使用会存在很多莫名奇妙的问题),如:


```java
List<?> list = new ArrayList<Integer>();
```

  **(六):你了解泛型通配符与上下界吗？**
    &emsp;&emsp;泛型通配符主要分为: 限定通配符(分为上边界通配符<? extends E>、下边界通配符<? super E>)和非限定通配符,具体作用如下:
    

 1. 边界通配符<? extends E> 表示: 泛型参数必须是E类型或者E的子类【这个只能用于方法参数,或者变量中修饰,不能修饰接口或类】

 2. 下边界通配符<? super E> 表示: 泛型参数必须是E或者E的父类,直至Object类型【这个只能用于方法参数,或者变量中修饰,不能修饰接口或类】

 3. 非限定通配符: 使用一个单独的T(或者A-Z任意字母)表示,它表示没有任何的限制,泛型参数可以是任意符合条件的类型。

#### 八:总结
&emsp;&emsp;相信看到这里,你对泛型的会有了更深的认识,学习一个知识,只有知道这个知识的原理,才不会感觉一知半解。<br>

&emsp;&emsp;**感谢你阅读本文,如果你觉得文章哪里存在错误,欢迎私信或者在下方留言指出。<font color='red' >如果你觉得本文对你有一些帮助,可以给我一个Star,谢谢**。
